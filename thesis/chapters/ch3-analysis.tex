\chapter{Analysis}
\label{ch:analysis}

Up to this point we described our system specification in detail.
Of course, specification along does not establish any truths.
In this chapter, we prove two aspects of our system.
First is correctness,
where we show that the consensus protocol and the validation protocol satisfies their desired properties
(\Cref{def:consensus} and \Cref{def:validation} respectively).
The second is performance,
where we prove the lower bound of our throughput and show that it out performs classical blockchain systems.

\section{Correctness}
Our first objective in this section is to establish truths regarding the correctness of our protocol.
We do this in two parts.
First we use mathematical induction to show that properties in \Cref{def:consensus} holds for all round.
Building on top that, if \Cref{def:consensus} is true, then we can show that many properties in \Cref{def:validation} is true.


\subsection{Correctness of Consensus}

We begin our analysis by establishing the fact that the $\textsf{get\_facilitator}(\cdot)$ is fair.
\begin{lemma}
\label{lemma:fairness}
% (Fairness of facilitator election)
Every node with a CP block in $\C_r$, should have an equal probability to be elected as a facilitator.
\end{lemma}
\begin{proof}
This directly follows from the random oracle model.
Recall that the luck value is computed using $\textsf{H}(\C_r, || pk_i)$.
Since $pk_i$ is unique for every node that has a CP block in $\C_r$, the output of $\textsf{H}(\cdot)$ is uniformly random.
This implies that the ordered sequence by luck value is uniformly random.
\end{proof}


Using \Cref{lemma:fairness}, we show that our consensus protocol satisfied \Cref{def:consensus}.
\begin{lemma}
\label{lemma:consensus}
% (Correctness of consensus)
$\forall r \in \mathbb{N}$, agreement, validity, fairness and termination holds.
\end{lemma}

\begin{proof}
We proof by mathematical induction.

In the base case, agreement, validity fairness and termination follows directly from the bootstrap protocol, due to the bootstrap oracle.
Note that the result is $\F_1$, which indicates the facilitators that are agreed in round 1 and are responsible for driving the ACS protocol in round 2.

For the inductive step, we assume that the properties hold for round $r$.
Then, to start round $r + 1$, the honest nodes begin sending CP blocks to $\F_r$. % TODO but they don't send at the same time!
Since the honest region in $\F_r$ waits for $D$ and $D \gg \Delta$,
the CP blocks of the honest nodes are guaranteed to be received by at least $n - t$ facilitators.
The agreement property of ACS (from \Cref{def:acs}) ensures that the $\C_{r + 1}$ is in consensus. 
Observe that $\F_{r + 1}$ is computed using the deterministic function $\textsf{get\_facilitators}(\cdot)$.
Thus agreement of $\F_{r + 1}$ follows directly from the agreement of ACS.
The validity property of ACS ensures that $\C_{r + 1}$ contains the input of at least $n - 2t$ parties, but this is a quorum containing at least one honest facilitator,
thus $\C_{r + 1}$ contains the CP blocks of all nodes.
Due to the assumption that the adversary cannot corrupt more than $t$ nodes,
validity of $\F_{r + 1}$ also follows from validity of ACS.
Since all honest nodes are in $\C_{r + 1}$, the fairness property follows directly from \Cref{lemma:fairness}.
Finally, the termination property holds because $D$ eventually elapses and then ACS eventually terminates
(the totality property of ACS).
This completes the proof.
\end{proof}

\subsection{Correctness of Validation}
The consensus protocol (on CP blocks and facilitators) is the backbone for consensus on transactions.
In this section we build on top of \Cref{lemma:consensus} to show that most properties in \Cref{def:validation} can be satisfied.

\begin{lemma}
% (Correctness of the validation protocol)
The validation protocol outputs the correct result
according to the validity definition.
\end{lemma}
\begin{proof}
The algorithm (\Cref{alg:get-validity}) is the validity definition.
\end{proof}

\begin{theorem}
\label{theorem:validation-agreement}
% (Agreement of the validation protocol)
If any correct node decides on the validity (except when it is \emph{unknown}) of a transaction,
then all other correct nodes are able to reach the same conclusion or \emph{unknown}.
\end{theorem}
\begin{proof}
We proof by contradiction.
Without loss of generality, for some transaction $t$ with an agreed fragment $F$,
node $u$ decides \emph{valid} but node $v$ decides \emph{invalid}.
Then there exist a fragment $F' = \{ \dots, t', c'\}$ which $u$ received that contains a valid pair of $t$---$t'$.
There also exist a fragment $F'' = \{ \dots, t'', c''\}$ which $v$ received that does not contain or contains an invalid pair---$t''$.
In both cases, the $\textsf{get\_validity}(\cdot)$ must have reached \Cref{line:valid-fragment}.
Due to \Cref{lemma:consensus}, we have $c' = c''$, otherwise the result would be \emph{unknown}.
Since $c' (= c'') = \langle \textsf{H}(t'), \dots \rangle$ we must have $\textsf{H}(t') = \textsf{H}(t'')$ and $t' \ne t''$ (because $t''$ is invalid).
In other words, the sender of $F''$ must be able to create some $t''$ that has the same digest as $t'$.
But we assumed that the adversary can only perform polynomial-time algorithm, but in order to find $t''$ it needs to query the random oracle exponentially many times.
Thus we have a contradiction and this completes our proof.
\end{proof}

\Cref{theorem:validation-agreement} is our first major result.
It shows that consensus on CP blocks would lead to consensus on TX blocks when the nodes are running the validation protocol.
One of the main advantages over running a consensus algorithm on all the transactions is that 
the rate of transaction is no longer dependent on the consensus algorithm---ACS (up to $L$ transactions).
This enables horizontal scalability where adding new nodes would lead to higher global transaction rate.
In addition, a convenient consequence \Cref{theorem:validation-agreement} is unforgeability.
That is, no polynomial time adversary is able to create two chains $F = \{ \dots, t, c\}$ $F' = \{ \dots, t', c\}$ with correct hash pointers and the same end of chain $c$.
% Another way to think about it is if a transaction can be forged, then it cannot be agreed.

However, not everything is perfect.
Now we show a negative result, where the liveness property cannot be attained.
\begin{lemma}
There exist a valid transactions that cannot be validated eventually.
\end{lemma}
\begin{proof}
We proof by providing a counterexample.
Suppose nodes $u$ and $v$ correctly perfomed the TX protocol which resulted a transaction $t$.
Then when $u$ wants to validate $t$, it does so by sending \texttt{vd\_req} message to $v$.
$v$ can act maliciously and ignore all \texttt{vd\_req} message, thus $t$ can never be validated.
\end{proof}
Although this is a negative result, it does not put the adversary in an advantageous position.
If the adversary is observed to ignore validation requests, then the honest nodes may prefer not to transact with her in the future.
Thus, to stay relevant in the system, the adversary need to comply to the protocol.

% \subsection{Chain structure}
% In this section we discuss how the adversary may tamper with the chain structure and its effects.
% The adversary can create invalid blocks, which are blocks that have an invalid hash pointer.
% The result is some chain with a broken link.

\section{Performance}
TODO intro

\subsection{Message Complexity of ACS}
\label{sec:acs-complexity}
The message complexity of ACS is $O(n^2|v| + \lambda n^3 \log n)$~\cite{miller2016honey},
where $|v|$ is the size of largest message and $\lambda$ is the security parameter.
Note that the security parameter is the same as the one for our random oracle described in \Cref{sec:model-assumptions}.
In particular, it is from the use of $\textsf{H}(\cdot)$ in the reliable broadcast phase in ACS.
In our system, we wish to understand the scalability properties.
Thus we consider the complexity as a function of $N$ rather than $n$ or $\lambda$.
Since $|v|$ is at most all the CP blocks from every node, we have $|v| = N$.
Therefore the message complexity of ACS in our system is $O(N)$.

\subsection{Bandwidth Requirement for Transactions}
To make and validate a transaction, the bandwidth required is of $O(l)$,
where $l$ is the length of the agreed fragment.
This can be seen from the fact that the largest message by far is the \texttt{vd\_resp} message,
which contains the agreed fragment,
the other messages (\texttt{tx\_req}, \texttt{tx\_resp} and \texttt{vd\_req}) are constant factors.
If we assume that every node performs transactions at a constant rate of $r_{\text{tx}}$ per second.
Then $l = (D_{\text{acs}} + D) \cdot r_{\text{tx}}$, where $D_{\text{acs}}$ is the duration an instance of ACS.
But from \Cref{sec:acs-complexity}, we know that $D_{\text{acs}}$ is of $O(N)$, thus the bandwidth per transaction is $O(N)$.
% TODO how does message complexity translate to time complexity?
% TODO computational task minimal compared to messages, thus the sending of message is expensive?
This is natural because consensus duration would be longer if there are more CP blocks, which means that the agreed fragments are longer.
This behaviour is also verified experimentally in \Cref{ch:implementation}.

\subsection{Global Throughput}
TODO