\chapter{Related Work}
\label{ch:related}

Having analysed our system both theoretically and experimentally,
we dedicate this chapter on comparing our results with related work.
Blockchain technology has seen a surge in recent years from both the industry and academia.
We classify the various blockchain systems by their consensus approach and divide them into the following categories: 
\begin{enumerate}
    \item classical blockchain systems,
    \item classical blockchain with offchain transactions,
    \item permissioned systems,
    \item hybrid systems and
    \item blockchains without global consensus.
\end{enumerate}
A few systems from each of these categories are compared with our design.

\section{Classical Blockchain Systems}
This category represent systems with a probabilistic probabilistic consensus algorithm.
That is, transactions never reach consensus with a probability of 1.
The typical examples are proof-of-work based systems such as Bitcoin, Ethereum and other Altcoins.
In Bitcoin, the level of consensus of a block\footnote{Note that a block in Bitcoin contain many transactions whereas our TX block only contain a single transaction.}
is determined how deep it is in the Bitcoin blockchain, also called the number of confirmation.
The probability of a block being orphaned drops exponentially as the depth increases~\cite{bitcoin}.
Nevertheless, the probability of the highest block being orphaned is non-negligible.
The advantage of this type of consensus is that it can be used in a large network and is reasonably secure.
Attackers can not out pace honest users in finding new blocks unless they have a majority of the hash power.
The disadvantage however is that transactions are never in consensus with a probability of 1---no consensus finality.
Also, the performance is limited due to the fact that blocks are of fixed size and are generated at fixed intervals.

Our system significantly improves upon Bitcoin and other classical blockchain systems in performance, scalability and consensus finality.
The results described in \Cref{ch:analysis} and \Cref{ch:implementation}, show that we have horizontal scalability,
where more nodes result in more global throughput.
Further, we do not have the aforementioned probabilistic behaviour,
once some consensus result is decided, it cannot be orphaned, thus our consensus is final.
The leadership election is also not ideal in classical blockchain systems.
Mining can be seen as a technique to elect a single leader.
The leader has full control of what goes into the block thus it may selectively censor transactions.
We use ACS, so as long as the CP block is in $n - 2t$ nodes, it is guaranteed to be in consensus.

However, the security aspect falls short of the ``honest majority'' security model that classical blockchains claim to 
have\footnote{Recently it was shown that doing selfish-ming would give the adversary an unfair advantage when she only controls 25\% of the mining power~\cite{eyal2014majority}}.
Our system risks going into erroneous state if the inequality $n \ge 3t + 1$ is not satisfied.
Classical blockchain systems also have an incentive mechanism, thus they do not depend on altruistic nodes and encourages participation.
Our system on the other hand does not have an incentive mechanism because we make no assumptions on the application.

\section{Offchain Transactions}
Offchain transactions make use of the fact that, if two or more parties frequently make transactions,
then it is not necessary to store every transaction on the blockchain, only the net settlement is necessary.
The best examples are Lightning Network~\cite{lightningnetwork} and full duplex channels~\cite{decker2015fast}.
These use the Bitcoin blockchain to store the net settlement and a payment channel to conduct offchain transactions.

Offchain transaction systems are implemented using multi-signature addresses~\cite{bitcoinmultisig} and hashed time-locked Bitcoin contracts~\cite{bitcointimelock}.
If two parties wish to make transactions, they open a time-locked payment channel with a multi-signature Bitcoin address (for two parties it would be a 2-of-2 signature address).
Transactions happen off the Bitcoin blockchain and are signed by both parties.
These transactions have a timestamp and only contain the net amount since the start of the payment channel.
Before the payment channel expires, the latest of such transactions is sent to the multi-signature address.
If multiple transactions are sent to the payment channel, the latest one is used.
After payment channel is closed, the net transaction is propagated to the Bitcoin blockchain.

The advantages of such systems is that they act as add-ons to Bitcoin wish already has a large number of users.
Thus, if enough of the network wish for it (by setting a new block version),
then a large number of users will instantly benefit from it.
It also shares the advantages of Bitcoin such as security and incentives.

On the other hand, offchain transactions also suffers from the problem of Bitcoin.
Proof-of-work is still problematic as it consumes an unreasonable amount of power.
Further, sidechain transactions are limited only to an exchange of cryptocurrency,
it is less general than typical Bitcoin transactions which may be a simple smart contract.
Time-locked contracts have a strong dependency on timing, thus disputes may arise when the payment channel is just about to close.
Our system is purely asynchronous and make no assumption on timing,
in fact we assume the adversary has control of the message delivery time and order.

\section{Permissioned Systems}

This category of systems use Byzantine consensus algorithms (discussed in \Cref{sec:acs-background}).
In essence, they contain a fixed set of nodes, sometimes called validators,
that run a Byzantine consensus algorithm to decide on new blocks.
This is known as a permissioned system where the validators must be pre-determined.
Some examples include Hyperledger and Tendermint.
The consensus algorithm used in these two systems is PBFT.

A nice aspect of Byzantine consensus and in particular PBFT is that it can handle much more transactions than classical blockchain systems.
But our system has the potential to perform beyond that of PBFT because we represent many transactions with a single CP block,
enabling horizontal scalability.
Furthermore, since PBFT relies on a leader, it is not censorship resiliant.
Our system on the other hand has the benifits of ACS where CP blocks cannot be censored.
Finally, our system is able to work in the permissionless setting by simply submitting new CP blocks to the facilitators.
It can even be adapted to work in the permissioned by simply removing the luck value computation.

What we wish to have which is in Hyperledger is a smart contract system (also known as chaincodes in Hyperledger).
We hope to design and implement smart contracts by adding additional logic to the transaction protocol and the validation protocol.
Such functionalities we believe is better to be built into the backbone rather than having it as an add on.


\section{Hybrid Systems}
Hybrid systems are very recent inventions.
Just like our work, they are attempts on solving the problems of traditional blockchains.
The main characteristic of these systems is that they use a classical blockchain technique,
i.e. proof-of-work, to elect a committee and prevent Sybils.
And then they use a Byzantine consensus algorithm to actually reach consensus on a set of transactions within the committee.
Some examples are SCP~\cite{luu2015scp}, ByzCoin~\cite{kogias2016enhancing} and Solidus~\cite{abraham2016solidus}.

Our approach share many similarities with the hybrid systems.
First, we also elect a committee (facilitators) to drive consensus.
But we do not have proof-of-work for Sybil defence because we believe 
it is possible to do it efficiently, e.g. using NetFlow~\cite{pimotte}.
Secondly, our use of CP blocks and ACS is also unique.
This creates a much higher throughput and enables censorship resiliance as mentioned earlier.
For instance, ByzCoin performs just below 1000 TPS with a thousand nodes whereas we peak at 8000 TPS.

A major side effect of these hybrid systems is that they cannot guarantee correctness when there is a large number of malicious nodes.
Our system has the same issue.
For SCP, ByzCoin and Solidus, they all have some probability to elect more than $n$ Byzantine nodes into the committee.
This problem is especially difficult solve because the committee is always much smaller than the population size which has more than $t$ Byzantine nodes,
thus electing more than $t$ nodes into the committee in always a possibility.
Classical blockchain do not have this problem because they do not use Byzantine consensus.
The permissioned systems work around this problem by trusting validators.

\section{Blockchains Without Global Consensus}

Tangle~\cite{tangle}, Corda~\cite{corda} and the original TrustChain~\cite{trustchain} do not use global consensus at all.
By avoiding global consensus, they are able to achieve extreme scalability.
Just like our approach, these blockchains are also application neutral where transactions can contain arbitrary data.

Our system can be considered as the same as these types of blockchains but with a lightweight consensus protocol.
Consensus might not be applicable in all applications.
But we believe it is important for detecting and preventing fraud.
The example in~\Cref{fig:trustchain-bad} on page~\pageref{fig:trustchain-bad} demonstrates this.
If $b$ makes a fork and $a$ and $c$ have no way to communicate (e.g. the adversary may control parts of the network) ,
then $c$ is tricked to believe that her transaction with $b$ is valid.
Only when $c$ sees a conflicting chain is she able to tell that the transaction is invalid.
But $c$ does not know the true end-of-chain of $b$, thus she can never know whether her transaction is valid.
This is not possible in our system because $b$ cannot convince $c$ unless he can compute exponential time algorithms
(this is finding the second preimage for a hash function).

However, consensus and validation comes at a cost that do not exist in Tangle, Corda or the original TrustChain.
Our transaction rate is affected by the validation protocol in the worst case scenario as we saw in~\Cref{sec:evaluation}.

