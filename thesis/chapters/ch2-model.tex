\chapter{System Architecture}
\label{ch:model}

The primary goal guiding our design is scalability.
As mentioned in the Introduction, having a scalable blockchain system while still keeping global consensus
allows the system to be ubiquitous and realise the full potential of blockchain.

The secondary goal is to design an application neutral system.
In particular, it should act as a framework that provides the building blocks of blockchain based applications.
Application developers using the framework should be able to create any application they wish.
Further, we do not impose on a consensus algorithm,
the application developer is free to choose between proof-of-work, proof-of-stake,
Byzantine consensus as long as it  satisfies the properties in \Cref{sec:todo}TODO.

Due to the nature of our system, we do not explicitly address the Sybil attack~\cite{douceur2002sybil}.
Sybil defence mechanism always require some form of reputation score from the application.
For example, social network based Sybil defence mechanims use graph structure of real-world relationships~\cite{yu2006sybilguard}.
Online marketplaces such as Amazon use the rating of buyer and sellers.
Thus it is not possible to design a Sybil defence mechanism with a a application neutral framework.
On the other hand, our system also has no restrictions on the Sybil defence technique
and application designers can pick the best mechanism for their application.

The third and final goal is security.
Our system should be unaffected in the presence of powerful adversaries.
Security is often difficult to verify, especially when it is not formalised, therefore we require our design to be provably secure.
To summarise, our system design is designed with the following goals in mind.
\begin{itemize}
    \item Application neutrality,
    \item scalability and
    \item security.
\end{itemize}

We begin the chapter with an intuitive overview of the architecture in \Cref{sec:system-overview}.
Next, we give the formal description, starting with the model and assumptions in \Cref{sec:model-assumptions}.
Then, the three protocols which make up the complete system,
namely consensus protocol (\Cref{sec:cons-protocol}), transaction protocol (\Cref{sec:tx-protocol}) and validation protocol (\Cref{sec:vd-protocol}).
Finally, the possible extensions are described in \Cref{sec:protocol-extensions}.


\section{System Overview}
\label{sec:system-overview}
The system consist of one data structure---Extended TrustChain,
and three protocols---consensus protocol, transaction protocol and validation protocol.
We first describe each component individually and then explain how they fit together in \Cref{sec:combined-protocol}.

\subsection{Extended TrustChain}
Extended TrustChain naturally builds on top of TrustChain, thus we first describe the standard TrustChain.
Our description has minor differences compared to the description in~\cite{trustchain}.
This is to help with the description of the extended TrustChain.
However, the two descriptions are functionally the same.

\subsubsection*{Standard TrustChain}
In TrustChain, every node has a ``personal'' chain. 
Initially, the chain only contains a genesis block.
When a node wishes to add a new transaction (TX), a new TX block is generated and is appended to the chain.
A TX block must have a valid hash pointer pointing to the previous block
and a reference\footnote{This is different from the original TrustChain definition found in~\cite{trustchain}.
In there, a TX block has two outgoing edges which are hash pointers to the two parties involved in the transaction.
This work uses one outgoing edge and a reference.} to its \emph{pair}.
As a result, a single transaction generates two TX blocks, one on each party's chain.
An example of is shown in \Cref{fig:trustchain-bad}.

\begin{figure}
    \includegraphics[width=0.9\textwidth]{trustchain-bad}
    \centering
    \caption{Every block is denoted by $t_{i,j}$, where $i$ is the node ID and $j$ is the sequence number of the block.
    Thus we have three nodes and three corresponding chains in this example.
    The arrows represent hash pointers and the dotted lines represent references.
    The blocks at the ends of one dotted line are pairs of each other.
    The red block after $t_{b, 5}$ indicate a fork.}
    \label{fig:trustchain-bad}
\end{figure}

If every node follows the rules of TrustChain and we only consider hash pointers,
then the chain effectively forms a singly linked list.
However, if a node violates the rules, then a \emph{fork} may happen.
That is, there may be more than one TX block with a hash pointer pointing back to the same block.
In \Cref{fig:trustchain-bad}, node $b$ (in the middle chain) created two TX blocks that both point to $t_{b, 5}$.
If this is a ledger system it can be seen as a double spend, where the currency accumulated up until $t_{b, 5}$ are spent twice.

\subsubsection*{Extended TrustChain}
We are now ready to explain the Extended TrustChain, which we abbreviate to ETC.
In ETC, we introduce a new type of block---checkpoint (CP) block.
In contract to TX blocks, CP blocks do not store transactions or contain references.
Their purpose is to capture the state of the chain and the state of the whole system.
In particular, the state of the chain is captured with a hash pointer.
The state of the whole system is captured in the content of the CP block,
namely as a digest of the latest \emph{consensus result} which we explain in \Cref{sec:overview-cons}.
A visual representation is shown in \Cref{fig:trustchain-bad-cp}.

\begin{figure}
    \includegraphics[width=0.9\textwidth]{trustchain-bad-cp}
    \centering
    \caption{The circles represent CP blocks,
    they also have hash pointers (arrow) but do not have references (dotted line).
    Note that the sequence number counter do not change, it is shared with TX blocks.}
    \label{fig:trustchain-bad-cp}
\end{figure}

\subsection{Consensus Protocol}\label{sec:overview-cons}
Before describing our consensus protocol, we take a brief detour to explain Byzantine consensus,
which is a fundamental building block of our consensus protocol.

\subsubsection*{Byzantine consensus}
Byzantine consensus is also known as \emph{atomic broadcast}.
Roughly speaking, atomic broadcast need to satisfy the following properties.
\begin{enumerate}
\item TODO
\end{enumerate}
TODO downsides (can't run with too many nodes) (high message complexity)
We stress that Byzantine consensus is not the same as Byzantine agreement or the Byzantine general's problem.
Byzantine agreement is TODO

The literature on Byzantine consensus and atomic broadcast is rich, some noteable ones include TODO.
Thus in the ETC consensus protocol, we assume there exist an "off-the-shelf" Byzantine consensus algorithm which we can use
(in our implementation we use HoneyBadgerBFT and motivate our choice in TODO).

In our case, every node do not propose some arbitrary data, but a set of CP blocks.
Thus the result of the consensus is the set union of all the legitimate proposals.

\subsubsection*{Consensus Protocol} 
The consensus protocol runs continuously in rounds.
That is because a blockchain systems always need to reach consensus on new values, or CP blocks in our case.
This can be seen as running infinitly many rounds of some Byzantine consensus algorithm,
starting a new execution immediately after the previous one is completed.

As we mentioned earlier, the high message complexity prohibits us from running a Byzantine consensus algorithm on a large network.
Thus, for every round, we randomly select some node---called facilitators---to collect CP blocks,
and then use the CP blocks as proposals of the Byzantine consensus algorithm.
The facilitators are elected using a \emph{luck value}, which is computed using $H(\C_r || pk_i)$,
where $\C_r$ is the consensus result in round $r$ and $pk_i$ is the public key of $i$.
Intuitively, the election is guaranteed to be random 
because the output of a cryptographically secure hash function is unpredictable and $\C_r$ cannot be determined in advance.

A visual explaination can be found in \Cref{app:consensus-example},
it walks through the steps needed for a node to be selected as a facilitator.

\subsection{Transaction and Validation}
The TX protocol is a simple request and response protocol.
The nodes exchange one round of messages and create new TX blocks on their respective chains.
Thus, as we mentioned before, one transaction should result in two TX blocks.

The consensus and transaction protocol by themselves do not provide a mechanism to detect forks or other forms of tamperaing.
Thus we need a validation protocol to counteract malicious behaviour.
When a node wish to validate one of its TX, it asks the counterparty for the \emph{fragment} of the TX.
A fragment of a TX is a section of the chain beginning and ending with CP blocks that contains the TX.
Upon the counterparty's response, the node checks that the CP blocks are in consensus, the hash pointers are valid and his TX is actually in the fragment.
The TX is valid if these conditions are satisfied.
Intuitively, this works because it is hard (because hash collision is hard)
 to create a different chain that begins and ends with the same two CP blocks but with a different middle section.


\subsection{Combined Protocol}
\label{sec:combined-protocol}
The final protocol is essentially the concurrent composition of the three aforementioned protocols,
all making use the Extended TrustChain data structure.

Our subprotocol design gives us the highly desireable non-blocking property.
In particular, we do not need to ``freeze'' the state of the chain for some communication to complete in order to create a block.
For instance, a node may start the consensus protocol, and while it is running, the node may still perform transactions.
By the time the consensus protocol is done, the new CP block is added to whatever the state that the chain is in.
It is not necessary to keep the chain immutable while the consensus protocol is running.

\section{Model and Assumptions}
\label{sec:model-assumptions}

For notational clarify, we use the following convention (adapted from~\cite{miller2016honey}) throughout this work.
\begin{itemize}
\item Lower case (e.g. $x$) denotes a scalar object or a tuple.
\item Upper case (e.g. $X$) denotes a set or a constant.
\item Sans serif (e.g. $\textsf{fn}(\cdot)$) denotes a function.
\item Typewrite (e.g. $\texttt{ack}$) denotes message type.
\end{itemize}

We assume a distributed network where nodes are fully connected,
the channels are reliable\footnote{
    Reliability can be achieved in unreliable networks by resending messages or using some error correction code.
},
but messages may be re-ordered and delayed by at most some time $\Delta$.
Nodes are identified by their public key thus we assume there exist a Public Key Infrastructure (PKI).
TODO this is weak synchrony?
In addition, we assume the existance of cryptographically secure hash function $\textsf{H}(\cdot)$,
that has preimage resistance, second preimage resistance and collision resistance.

In our model we consider $N$ nodes, which is the population size.
$n$ of them are facilitators, $t$ out of $n$ are malicious and the inequality
$n \ge 3t + 1$ must hold.

The primary data structure used in our system is Extended TrustChain.
Each node $u$ has a public and private key pair---$pk_u$ and $sk_u$, and a chain $B_u$.
The chain consist of blocks $B_u = \{ b_{u, i} : k \in \{ 0, \dots, h - 1 \} \}$,
where $b_{u, i}$ is the $i$th block of $u$,
and $h = |B_u|$.
We often use $b_{u, h}$ to denote the latest block.
There are two types of blocks, TX blocks and CP blocks.
If $T_u$ is the set of TX blocks of $u$ and $C_u$ is the set of CP blocks of $u$,
then it must be the case that $T_u \cup C_u = B_u$ and $T_u \cap C_u = \varnothing$.
The notation $b_{u, i}$ is generic over the block type.
We assume there exist a function $\textsf{typeof}: B_u \rightarrow \{ \tau, \gamma \}$ that returns the type of the block,
where $\tau$ represents the TX type and $\gamma$ represents the CP type.

\subsection{TX Block}
The TX block is a six-tuple, i.e $t_{u, i} = \langle \textsf{H}(b_{u, i - 1}), seq_u, txid, pk_v, m, sig_u \rangle$.
We describe each item in turn.
\begin{enumerate}
\item $\textsf{H}(b_{u, i - 1})$ is the hash pointer to the previous block.
\item $seq_u$ is the sequence which should equal $i$.
\item $txid$ is a cryptographically secure random number representing the transaction identifier.
\item $pk_v$ is the public key of the counterparty.
\item $m$ is the transaction message.
\item $sig_u$ is the signature created using $sk_u$ on the concatination of the binary representation of the five items above.
\end{enumerate}
The fact that we have no constraint on the content of $m$ is in alignment with our design goal---application neutrality.

TX blocks come in pairs.
In particular, for every block $t_{u, i} = \langle \textsf{H}(b_{u, i - 1}), seq_u, txid, pk_v, m, sig_u \rangle$
there exist one and only one \emph{pair} $t_{v, j} = \langle \textsf{H}(b_{v, j - 1}), seq_v, txid, pk_u, m, sig_v \rangle$.
Note that the $txid$ and $m$ are the same, and the public keys refer to each other.
Thus, given a TX block, these properties allow us to identify its pair.

% TODO Node $v$ may cheat and create more than one pair for $t_{u, i}. we discuss later

\subsection{CP Block}

The CP block is a five-tuple, 
i.e. $c_{u, i} = \langle \textsf{H}(b_{u, i-1}), seq_u, \textsf{H}(\C_r), r, sig_u \rangle$,
where $\C_r$ is the consensus result in round $r$, the other items are the same as the TX block definition.
Note that unlike in our prior work~\cite{implicitconsensus}, CP blocks and TX blocks do not have independent sequence numbers.

The genesis block in the chain must be a CP block in the form of
$c_{u, 0} = \langle \textsf{H}(\bot), 0,  \textsf{H}(\bot), 0, sig_u \rangle$
where $\textsf{H}(\bot)$ can be interpreted as applying the hash function on an empty string.
The genesis block is unique due to every node due to $sig_u$.


\subsection{Consensus Result}
Our consensus protocol runs in rounds as discussed in \Cref{sec:system-overview}.
Every round is identified by a round number $r$, which is incremented on every new round.
The consensus result is a tuple, i.e. $\C_r = \langle r, C \rangle$,
where $C$ is a set of CP blocks agreed by the facilitators of round $r$.

\subsection{Chain Properties}
Here we define a few important properties which results from the interleaving nature of CP and TX blocks.

If there exist a tuple $\langle c_{u,a}, c_{u, b} \rangle$ for a TX block $t_{u, i}$,
where 
$$a = \argmin_{k, k < i, \texttt{typeof}(b_{u,k}) = \gamma}(i - k)$$
$$b = \argmin_{k, k > i, \texttt{typeof}(b_{u,k}) = \gamma}(k - i),$$
then $\langle c_{u,a}, c_{u, b} \rangle$ is the \emph{enclosure} of $t_{u, i}$.
Some TX blocks may not have any subsequent CP blocks, then its enclosure is $\bot$.

If the enclosure of some TX block is $\langle c_{u,a}, c_{u, b} \rangle$,
then its \emph{fragment} is computed as $\{ b_{u, i} : a \le i \le b \}$.
For convenience, the function $\textsf{fragment}(\cdot)$ represents the fragment of some TX block if it exists, otherwise $\bot$.

\emph{Agreed enclosure} is the same as enclosure with an extra constraint where the CP blocks must be in some consensus result $\C_r$.
Similarly, \emph{agreed fragment} is computed using agreed enclosure.
We define its function to be $\textsf{agreed\_fragment}(\cdot)$

The length of the fragment is constrained by $L$,
namely $\forall t |\textsf{fragment}(t)| \le L$.
The purpose to prevent spam and encourage nodes to create more CP blocks.
$L$ should be sufficiently high so that busy nodes are not hindered by it.

\section{Consensus Protocol}
\label{sec:cons-protocol}

Our consensus protocol runs on top of the model describe before, it makes heavy use of CP blocks.
We describe the protocol step by step.
Starting with the bootstrap phase and then moving on to the actual consensus phase.

\subsection{Bootstrap Phase}
\label{sec:bootstrap}
Recall that facilitators are computed from the consensus result,
but the consensus result is agreed by the facilitators.
Thus we have a dependency cycle.
The goal of the bootstrap phase is to give us a starting point for the cycle.

Our bootstrap phase runs as follows.
First we assume all $N$ nodes start simultaneously.
The facilitators for round 0 are hard coded in the program,
in practice this could be the machines controlled by the developer.
If some node $u$ not a facilitator,
it sends the message $\langle \texttt{cp\_msg}, c_{u, 0} \rangle$ to all the facilitators.
If $u$ is a facilitator, it does the same, but also waits for some time $\Delta + 1$ to collect messages of type \texttt{cp\_msg}.
After $\Delta + 1$ elapses, it begins the atomic broadcast protocol using the collected CP blocks as the proposal.
$\C_0$ is agreed at the end of the protocol.
This concludes the bootstrap phase.

The bootstrap phase can be seen as an idealised version of the setup phase combined with the consensus phase,
which we describe next.

\subsection{Setup phase}
The setup phase begins immediately after some consensus result is agreed, but not yet disseminate.
This could be right after the bootstrap phase.
The goal is to reach agreement on a list of new facilitators between every node.
Concretely, for every consensus round $r$, the following is required.
\begin{enumerate}
\item \emph{Agreement}: If any correct node receives $\C_r$,
  then every correct node receives $\C_r$.
\item \emph{Liveness}: All $N - t$ correct nodes receives a value eventually.
\end{enumerate}

The setup phase works as follows.
Assume that facilitators of round $r-1$ have just agreed on $\C_{r-1}$.
They then immediately broadcast two messages to all the nodes---
first the consensus message $\langle \texttt{cons\_msg}, \C_{r-1} \rangle$,
and second the signature message $\langle \texttt{cons\_sig}, r, sig \rangle$.

We make two remarks regarding those message.
First, broadcasting is inefficient in terms of message  complexity.
Gossiping is often better in practice but it introduces additional complexity due to its probabilistic nature.
Thus, to keep the analysis clear in \Cref{sec:analysis}, we use broadcasting.
Second, recall that channels are not authenticated, 
and there are no signatures in $\C_{r - 1}$.
If a non-facilitator sees some $\C_{r - 1}$, it cannot immediately trust it because it may have been forged.
Thus, To guarantee authenticity, every facilitator sends an additional message that is the signature of $\C_r$.

Continuing with the setup phase.
Upon receiving $\C_{r - 1}$ and at least $t + 1$ valid signatures by $u$, $u$ performs two asks.
First, it computes the new facilitators using $\textsf{derive\_facilitator}(C, n)$ (\Cref{alg:facilitator})
and updates its facilitator list to the result.
Second, it creates a new CP block using $\textsf{new\_cp}(\C_{r - 1}, r - 1)$ (\Cref{alg:new-cp}).
This concludes the setup phase.

\begin{algorithm}
\caption{Function $\textsf{derive\_facilitator}(C, n)$ takes a list of CP blocks $C$ and an integer $n$,
sort evey element in $C$ by its luck value (the $\lambda$-expression), and outputs the smallest $n$ elements.}
\label{alg:facilitator}
\begin{algorithmic}
\State $\textbf{take} (n, \textbf{sort} (\textbf{map}(\lambda x.\textsf{H}(x || pk \text{ of } x), C)))$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Function $\textsf{new\_cp}(\C_r, r)$ runs in the context of the caller $u$. TODO}
\label{alg:new-cp}
\begin{algorithmic}
\State $h \gets |B_u|$
\State $c_{u, h} \gets \langle \textsf{H}(b_{u, h-1}), h, \textsf{H}(\C_r), r, sig_u \rangle$
\State $B_u \gets B_u \cup c_{u, h}$
\end{algorithmic}
\end{algorithm}

\subsection{Consensus Phase}
The consensus phase begins after the new facilitators are selected.
Assuming the facilitators are of round $r$,
the goal is to agree on some $\C_r$ between the facilitators.
There are two scenarios in the consensus phase.
First, if node $u$ is not the facilitator, it sends $\langle \texttt{cp\_msg}, c_{u, h} \rangle$ to all the facilitators.
Second if the node is a facilitator, it waits for some duration $\delta$ and collect messages of type \texttt{cp\_msg}.
After $\delta$ is elapsed, it begins the atomic broadcast algorithm.
In particular, the facilitators must satisfy the following conditions.
\begin{enumerate}
\item \emph{Agreement}: If any correct node outputs a CP block $c$, then every
  correct node outputs $c$.
\item \emph{Total Order}: If one correct node outputs the sequence of CP blocks
  $\{c_1, c_i, \dots, c_n\}$ and another has output $\{c'_0, c'_1, \dots,
  c'_{n'} \}$, then $c_i = c'_i$ for $i \le \min(n, n')$.
\item \emph{Liveness}: All $n - t$ correct nodes terminate eventually.
\end{enumerate}

We remark that this procedure is the same as what is described in the bootstrap phase (\Cref{sec:bootstrap}),
but the precondition and the waiting time is different.
In particular, the bootstrap stage assumed that every node initiated and sent the \texttt{cp\_msg} simultaneously,
but here we make no such assumption. Further, the bootstrap waits for duration $\Delta$ in order to collect all the CP blocks,
here we wait for some $\delta$ which is a system variable.
We make no assumption on the value of $\delta$ in relation to $\Delta$,
thus it may be the case that not all \texttt{cp\_msg} are delivered before the the facilitators begins the atomic broadcast protocol.

TODO assume the wait time is much longer than network delay.

At the core of the consensus phase is the atomic broadcast protocol.
While using any atomic broadcast protocol will suffice,
we use a (minimal) simplification of HoneyBadgerBFT as it is designed for blockchain systems and runs in fully asynchronous networks.
The transactions in HoneyBadgerBFT are first queued in a buffer, the main consensus algorithm starts only when the buffer reaches an optimal size.
We do not have an infinite stream of CP blocks, thus buffering is unsuitable.
The main algorithms are kept the same, namely Asynchronous Common Subset, Reliable Broadcast and Binary Agreement.
At the end of the consensus sphase, some $\C_r$ should be agreed upon.
This bring us back to the setup phase and the cycle can be started again.


\section{Transaction Protocol}
\label{sec:tx-protocol}

The TX protocol, shown in \Cref{alg:tx-proto}, is run by all nodes.
It is also known as True Halves, first described by Veldhuisen~\cite[Chapter~3.2]{truehalves}.
Node that wish to initiate a transaction calls $\textsf{new\_tx}(pk_v, m, txid)$ (\Cref{alg:new-tx}) with the intended counterparty $v$ identified by $pk_v$ and message $m$.
$txid$ should be a uniformly distributed random value, i.e. $txid \in_R \{0, 1\}^{256}$.
Then the initiator sends $\langle \texttt{tx\_req}, t_{u, h}\rangle$ to $v$.

\begin{algorithm}
    \caption{Function $\textsf{new\_tx}(pk_v, m, txid)$ generates a new TX block and appends it to the caller $u$'s chain.
    It is executed in the private context of $u$, i.e. it has access to the $sk_u$ and $B_u$.
    The necessary arguments are the public key of the counterparty $pk_v$, the transaction message $m$ and the transaction identifier $txid$.}
    \label{alg:new-tx}

    \begin{algorithmic}
    \State $h \gets |B_u|$
    \State $t_{u, h} \gets \langle \textsf{H}(b_{u, h - 1}), h, txid, pk_v, m, sig_u \rangle$
    \State $B_u \gets B_u \cup \{ t_{u, h} \}$
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
    \caption{The TX protocol which runs in the context of node $u$. TODO}
    \label{alg:tx-proto}

    \begin{algorithmic}
        \Upon $\langle \texttt{tx\_req}, t_{v, j} \rangle$ from $v$
        \State $txid, pk_v, m \gets t_{v, j}$ \Comment unpack the TX
        \State $\textsf{new\_tx}(pk_u, m, txid)$
        \State store $t_{v, j}$ as the pair of $t_{u, h}$
        \State send $\langle \texttt{tx\_reqp}, t_{u, h} \rangle$ to $v$

        \Upon $\langle \texttt{tx\_resp}, t_{v, j} \rangle$ from $v$
        \State $txid, pk_v, m \gets t_{v, j}$ \Comment unpack the TX
        \State store $t_{v, j}$ as the pair of the TX with identifier $txid$
    \end{algorithmic}
\end{algorithm}

A key feature of the TX protocol is that it is non-blocking.
At no time in \Cref{alg:new-tx} or \Cref{alg:tx-proto} do we need to hold the chain state and wait for some message to be delivered before committing a new block to the chain.
This allows for high concurrency where we can call $\textsf{new\_tx}(\cdot)$ multiple times without waiting for the corresponding \texttt{tx\_resp} messages.

\section{Validation Protocol}
\label{sec:vd-protocol}

Up to this point, we do not provide a mechanism to detect forks or other forms of tampering or forging, and we cannot detect malicious parties.
The validation protocol aims to solve this issue.
The protocol is also a request-response protocol, just like the transaction protocol.
But before explaining the protocol itself, we first define what it means to be valid.

\subsection{Validity Definition}
A \emph{valid} TX must be created by following the TX protocol.
Concretely, a TX $t_{u, i} = \langle \textsf{H}(b_{u, i - 1}), i, txid_u, pk_v, m_u, sig_u \rangle$ should satisfy the following conditions.
\begin{enumerate}
    \item \emph{Existance of pair}:
        There exists $t_{v, j} = \langle \textsf{H}(b_{v, j - 1}), j, txid, pk_u, m, sig_v \rangle$,
        i.e. the pair, where $txid_u = txid_v$, $m_u = m_v$ and the signatures are valid.
    \item \emph{Existance of fragment}:
        There exists $\textsf{agreed\_fragment}(t_{u, i})$---call it $F_{u, i}$ and
        $\textsf{agreed\_fragment}(t_{v, j})$---call it $F_{v, j}$,
        where the hash pointers are valid and the enclosing CP blocks have valid signatures.
    \item \emph{Only one pair}:
        There is only one transaction with $txid$ in $F_{v, j}$.
    \item \emph{Small fragment}:
        The $|F_{u, i}| \le L$ and $|F_{v, j}| \le L$.
    \item \emph{Same consensus round}:
        Suppose the last block in $F_{u,i}$ and the last block in $F_{v, j}$ are respectively $c_{u, p}$ and $c_{v, q}$. 
        Then these they must be created from the same consensus round.
\end{enumerate}
We make three remarks regarding the definition.
Firstly, the existance of fragment is the most important property.
It ensures that the pair of TX blocks exist between a pair of CP blocks that are in consensus.
This implicitly proves that the TX blocks are in consensus (we show a proof in \Cref{sec:analysis} TODO).
Secondly, the same consensus round property is to encourage node to remain active in the network.
Recall that the facilitators waits for duration $\Delta$, which is much longer than the network delay.
Thus the \texttt{cp\_msg} should be delivered to the facilitators before the consensus starts.
Lastly, TX blocks that do not satisfy the requirement above are not invalid.
In fact, most new TX blocks cannot satisfy the Existance of fragment property because the CP blocks following the new transactions have not reached consensus.
Moreoever, very new TX blocks may not satisfy the Existance of pair property because the counterparty may have not yet sent \texttt{tx\_resp}.
Next we define \emph{invalid} transactions.
\begin{enumerate}
    \item \emph{Bad pair}:
        $txid_u = txid_v \wedge m_u \ne m_v$.
    \item \emph{Invalid counterparty}:
        $txid_u = txid_v$, but $pk_u$ in $t_{v, j}$ does not match $u$'s public key.
    \item \emph{Invalid hash pointer}:
        Suppose $F_{u, i}$ and $F_{v, j}$ are available, but the transactions in the fragments do not form a chain.
    \item \emph{Large fragment}:
        $F_{u, i} > L \vee F_{v, j} > L$.
    \item \emph{Different consensus round}:
        The last block in $F_{u,i}$ and the last block in $F_{v, j}$ are respectively $c_{u, p}$ and $c_{v, q}$. 
        But these CP blocks are not created from the same consensus round.
\end{enumerate}
The final two properties are the negation of the final two properties in the valid definition.
The other three properties are for detecting tampering.
Any transaction that do not fall into the valid or invalid category are known as \emph{unknown} transactions.

\subsection{Validation Protocol}
With the validity definition, we are ready to construct a protocol for determining the validity of transactions.
The protocol is a simple response and request protocol (\Cref{alg:vd-proto}).
If $u$ wishes to validate some TX with ID $txid$ and counterparty $v$, it sends $\langle \texttt{vd\_req}, txid \rangle$ to $v$.
The desired properties of the validation protocol are as follows.
\begin{enumerate}
    \item \emph{Correctness}:
        The validation protocol outputs the correct result
        according to the aforementioned validity definition.
    \item \emph{Agreement}:
        If any correct node decides on the validity of a transaction,
        then all other correct nodes are able to reach the same conclusion.
    \item \emph{Liveness}:
        Any valid transactions can be validated eventually.
    \item \emph{Unforgeability}:
        If some transaction is valid, it cannot be forged into an invalid transaction.
        If some transaction is invalid, it cannot be forged into a valid transaction.
\end{enumerate}

\begin{algorithm}
\caption{Validation protocol}
\label{alg:vd-proto}

\begin{algorithmic}
    \Upon $\langle \texttt{vd\_req}, txid \rangle$ from $v$
        \State $t_{u, i} \gets \text{the transaction identified by } txid$
        \State $F_{u, i} \gets \textsf{agreed\_fragment}(t_{u, i})$
        \State send $\langle \texttt{vd\_resp}, txid, F_{u, i} \rangle$ to $v$

    \Upon $\langle \texttt{vd\_resp}, txid, F_{v, j} \rangle$ from $v$
        \State $t_{u, i} \gets \text{the transaction identified by } txid$
        \State set the validity of $t_{u, i}$ to $\textsf{get\_validity}(t_{u, i}, F_{v, j})$
\end{algorithmic}
\end{algorithm}

The core of the validation protocol lies within the $\textsf{get\_validity}(\cdot)$ function (\Cref{alg:get-validity}).
It essentially implements all the aforementioned validity requirements.
If they are all satisfied, the function returns \emph{valid}.
Otherwise, depending on which stage the function failed, it will return either \emph{unknown} or \emph{invalid}.
We prove in the following chapter that the validation protocol satisfies the most of the desired properties.

\begin{algorithm}
\caption{Function $\textsf{get\_validity}(t_{u, i}, F_{v, j})$ runs in the private context of $u$.
$t_{u, i}$ is the transaction that $u$ wishes to verify, and $F_{v, j}$ is the corresponding fragment received from $v$.}
\label{alg:get-validity}

\begin{algorithmic}

    \State $F_{u, i} \gets \textsf{agreed\_fragment}(t_{u, i})$
    \If{$F_{u, i} = \bot$}
        \State \Return \emph{unknown}
    \EndIf
    \State

    \State $c_{v, a} \gets \textsf{first}(F_{v, j})$
    \State $c_{v, b} \gets \textsf{last}(F_{v, j})$
    \If{$c_{v, a}$ or $c_{v, b}$ are not in consensus}
        \State \Return \emph{unknown}
    \EndIf
    \State

    \State $txid, pk_v, m \gets t_{u, i}$
    \If{number of blocks of $txid$ in $F_{v, j} = 0$}
        \State \Return \emph{unknown}
    \EndIf
    \State 

    \If{number of blocks of $txid$ in $F_{v, j} > 1$}
        \State \Return \emph{invalid}
    \EndIf
    \State 

    % txid are equal now, but bad hash pointer
    \If{sequence number in $F_{v, j}$ is correct (sequential)}
        \If{hash pointers in $F_{v, j}$ is wrong}
            \State \Return \emph{invalid}
        \EndIf
    \EndIf
    \State

    \State $txid', pk'_u, m' \gets t_{v, j}$
    \If{$m \ne m' \vee pk_u \ne pk_u \vee |F_{v, j}| > L$}
        \State \Return \emph{invalid}
    \EndIf
    \State

    \State $c_{u, b} \gets \textsf{last}(F_{u, i})$
    \If{$c_{u, b}$ is not created using the same $\C_r$ as $c_{v, b}$}
        \State \Return \emph{invalid}
    \EndIf
    \State

    \State \Return \emph{valid}
\end{algorithmic}
\end{algorithm}

We make two remarks.
First, just like the TX protocol, we do not block at any part of the protocol.
Second, suppose some $F_{v, j}$ validates $t_{u, i}$, then that does not imply that $t_{u, i}$ only has one pair $t_{v, j}$.
Our validity requirement only requires that there is only one $t_{v, j}$ in the correct consensus round.
The counterparty may create any number of fake pairs in a later consensus rounds.
But these fake pairs only pollutes the chain of $v$ and can never be validated because the round is incorrect.

\section{Protocol Extensions}
\label{sec:protocol-extensions}


% \section{Universally Composable Framework}
% \label{sec:uc-intro}

% In order to analyse the security of a system, a formal notion of security is required.
% For instance, what does it mean if an encryption algorithm is secure?
% One may say it is secure if the adversay cannot learn any information about the plaintext from the ciphertext.
% But what if the adversay has some background information, for instance she may know it is English.
% Do we then still say the encryption algorithm is secure?
% Goldwasser and Micali introduced the notion of semantic security~\cite{goldwasser1982probabilistic}.
% That is, imagine two worlds, a real world and an ideal world.
% In the real world, the adversay is given the ciphertext,
% and in the ideal world the adversay has nothing.
% Then the encryption algorithm is semantically secure if the amount of information that the adversay can learn in the real world is just as much as the ideal world.
% While our description is informal, the notion of security can be formally captured in this way.

% Security sensitive distributed systems such as secure multi-party computation and blockchain systems also require a formal notion of security so that they can be analysed.
% Fortunately, the idea from semantic security can also be applied in a distributed setting.
% In an ideal world, we create an ideal functionality $\Fideal$ that performs all the computation on behalf of every node in the network.
% The nodes act as dummies and only relay messages between $\Fideal$ and the environment.
% Thus $\Fideal$ essentially becomes the specification of the distributed protocol.
% If the execution of the real world protocol is indistinguishable from the ideal emulation in the presence of some adversay,
% then the real world protocol is secure as per the ideal specification.
% This is in essence the Universally Composable (UC) framework.

% We use the UC framework not only because it suits our needs, 
% it is also the only framework used in modelling blockchain systems to the best of our knowledge
% ~\cite{todo}TODO.
% In the remainder of this section we give an overview of the UC framework.
% A detailed treatment  can be found in~\cite{canetti2001universally}.

% \subsection{Model of Computation}
% The model of computation considered in the UC framework is the interactive Turing machine (ITM).
% Specifically, an ITM is an extension of the Turing machine with externally writable tapes which are the following.
% \begin{enumerate}
% \item input tape---TODO
% \item incoming communication tape---TODO
% \item subroutine output tape---TODO
% \end{enumerate}
% ITM can be seen as a specification or an algorithm, a machine running an ITM is an ITM instance (ITI).
% To communicate, an ITI can write on the externally writable tapes of other ITIs.
% The writing ITI then pauses exeuction, the receiving ITI begins execution.
% Consequently, only one ITI is running at any point in time.

% \subsection{Simulation-based Security}
% Simulation-based security, also known as ideal/real paradigm is a model for defining security.
% The model consist of a set of , the environment $\E$, the adversay $\A$,
% the protocol ITM $\Preal$ and zero or more ideal functionalities $\mathcal{F}_0, \mathcal{F}_1, \dots$.
% The 
% Other than the machines running the protocol under consideration, the model contains two extra entities,
% the environment $\E$ and the adversary $\A$.
% $\E$ can be seen as users of the protocol, it can only provide input and receive output from $\A$ and the protocol.

% Control function TODO

% \subsection{Universal Composability}

% \section{Formal Specification}
% \label{sec:formal-model}

% The formal model follows the same structure as \ref{fig:todo}TODO.

% \begin{figure}[h]
% \begin{framed}
% \small  % end with \normalsize

% \textbf{Protocol}\,$\Preal$

% The ETC protocol. On initialisation do the following.
% \begin{itemize}
% \item Generate public and private key pair, $pk$ and $sk$.
% \item Set personal chain $C := \{genesis()\}$.
% \item Set checkpoint buffer $\C' := \varnothing$.
% \item Set the facilitators $F$ to the bootstrap nodes provided by $\E$.
% \item Set the latest round $r_{\text{latest}} = 0$.
% \end{itemize}

% Run the protocol as specified below after initialisation.
% \begin{itemize}

% \item Upon (\texttt{consensus}, $D$) from $\F^r_\text{BFT}$,
%     if $r_{\text{latest}} >= r$ then do nothing and pause,
%     otherwise do $try_add_cp(D, r)$
%     send (\texttt{propose})

% \item Upon (\texttt{consensus}, $D$, $r$) from $p \in \P$,

% \item Upon (\texttt{checkpoint}, $c$) from $p \in \P$,

% \item Upon (\texttt{tx\_init}, $m$, $p$) from $\E$, 
%     $C := C \cup \{new\_tx(m)\}$,
%     send (\texttt{tx\_req}, latext TX in $C$) to $p$.

% \item Upon (\texttt{tx\_req}, $m$) from $p \in \P$,
%     $C := C \cup \{new\_tx(m)\}$,
%     let $m'$ be the latest TX in $C$ and set $m$ to be the other half of $m'$,
%     send (\texttt{tx\_resp}, $m'$) to $p$.
%     Output the complete TX to $\E$.

% \item Upon (\texttt{tx\_resp}, $m'$) from $p \in \P$,
%     find the corresponding pair of $m'$ and name it $m$,
%     add $m'$ as the other half of $m$.
%     Output the complete TX to $\E$.

% \item Upon (\texttt{vd\_init}, $s$) from $\E$,
%     if the sequence number $s$ does not exist in $C$ or the block with $s$ does not have the other half then do nothing.
%     Otherwise send (\texttt{vd\_req}, $s'$) to $p'$ where $s'$ is the sequence number of the other half and $p'$ is the counterparty.

% \item Upon (\texttt{vd\_req}, $s'$) from $p \in \P$,
%     if the sequence number $s'$ does not exist then do nothing.
%     Otherwise send (\texttt{vd\_resp}, $agreed\_fragment(s')$) to $p$.

% \item Upon (\texttt{vd\_resp}, $x$) from $p \in \P$,
%     run $validate(x)$ and output result to $\E$.

% \end{itemize}

% \normalsize
% \end{framed}
% \end{figure}

% \begin{framed}
% \textbf{Functionality}\,$\F^r_\text{BFT}$

% The ideal Byzantine consensus protocol, parameterised by the round number $r$.

% \begin{itemize}
% \item Upon (\texttt{propose}, $r$, $C$),
% \item Upon (\texttt{fetch}),
% \end{itemize}
% \end{framed}

% \subsection{Discussion}

% \subsubsection{Global clock for synchronisation}
% Where there is no Byzantine corruption, we conjecture that our protocol runs in the asynchronous setting.
% However, security of many Byzantine consensus algorithms, especially the one we adopted---HoneyBadgerBFT,
% fall apart when there is dynamic corruption.
% In order to enforce that the corrupted machines do not change when running an instance of some Byzantine consensus algorithm,
% we introduce synchrony.

% We make use of a global clock... TODO

% Dynamic corruption only between different clock ticks is enforced by the control function.

% \subsubsection{Static corruption versus dynamic corruption}
% A subtlety exists when modelling the type of corruption.
% In dynamic corruption\footnote{In \cite{canetti2001universally}, dynamic corruption is termed Byzantine corruption.},
% $\A$ take full control of a number of machines and also learns all of their states.
% The states include private keys.
% Thus, using the dynamic corruption model from \cite{canetti2001universally} we cannot guarantee security as
% $\A$ can corrupt different machines over time and eventually learn all the private keys..

% First is to use static corruption, where the corrupted machines are fixed.
% While this circumvents our problem, it is a much weaker model.
% Alternatively, we modify the aforementioned dynamic corruption model and weaken the adversary's abilities.
% In particular, we introduce that forgetful adversary that only remembers the state of the currently corrupted nodes and forget the state of the recovered nodes.


