\chapter{Problem description}
\label{ch:problem}

The decentralised and democratic nature of blockchain technology removes central point of control or failure.
However, as we described in the Introduction, it faces a genuine scalability problem.
In particular, proof-of-work based systems are unlikely to reach a transaction rate suitable for ubiquitous use, even with parameter tuning.
What we wish to see is horizontal scalability.
That is, by adding new nodes into the network, the global transaction rate should increase proportionally.
Hence, the research question we answer in this  work is the following.
\begin{displayquote}
\emph{Is it possible to design a blockchain consensus protocol that is fault tolerant, scalable and can reach global consensus?}
\end{displayquote}

In order to make sense of our research question, we must first define \emph{blockchain consensus protocol}.
Typical blockchain systems are application specific.
For example, the application in Bitcoin (any many of its derivatives) is digital cash, the application in Namecoin is domain name registration~\cite{namecoin} and the application in Siacoin is cloud storage~\cite{siacoin}.
Underneath these applications lies the blockchain consensus protocol which has the goal of reaching consensus on transactions or state changes.
In the case of Bitcoin it is proof-of-work (PoW).
It is not concerned with the structure of the transactions,
it works by simply treating transactions as a blob of data and hashes them with the previous block.
In this work, we focus on the blockchain consensus protocol rather than any specific application.
Because it is the scalability bottleneck and is neccessary for any blockchain based application.
% Also, it should be possible to build any kind of application on top our system.
% We do not impose on a consensus algorithm, as long as it satisfies the properties of atomic broadcast which we describe in~\Cref{sec:overview-cons}.

In the remainder of this chapter we expand on our research question and visit each of our requirement in detail.
At the end of this chapter we describe some issues that we do not consider as a part of our design,
which is the result of not focusing on any specific application.

\section{Global consensus}

% why consensus is important
% The first objective is to reach consensus on a global \emph{state}.
% We emphasise the word state because in contrary to traditional blockchains,
% it does not neccessarily mean the set of all transactions that has ever happened.
% The state can be a verifiable representation of all the transactions.
% As an extreme example, a single digest of the complete history can represent the state.
% It is even verifiable as long as there are nodes that stores the history.

Early blockchain systems use PoW as the consensus algorithm,
but consensus algorithm and especially Byzantine\footnote{Byzantine means participants can experience arbitrary failure, more on this in~\Cref{sec:acs-background}.}
consensus algorithms have existece since the 80s~\cite{pease1980reaching, lamport1982byzantine}.
The Practical Byzantine Fault Tolerance (PBFT) algorithm introduced in 1999 by Castro and Liskov~\cite{castro1999practical} is widely regarded as the first high-performance consensus algorithm.
The authors show that running PBFT in Network File System (NFS) was only 3\% slower than the standard unreplicated NFS.
Since then, research in this area picked up pace and many more algorithms are introduced, for example Q/U~\cite{abd2005fault} and Zyzzyva~\cite{kotla2007zyzzyva}.
With the introduction of Bitcoin's probabilistic consensus model, the field experienced a second renaissance.
These include proof-of-stake protocols~\cite{bentov2016snow, micali2016algorand}, as well as protocols optimised for blockchain~\cite{liu2016xft, miller2016honey}.

The first objective is to reach consensus on a global \emph{state} by standing on the shoulder of giants.
Having consensus is essential in blockchain systems.
It stops many types of malicious activities because agreed state must have the consent of the honest nodes in the network.
We emphasise the word state because in contrary to traditional blockchains,
it does not neccessarily mean the set of all transactions that has ever happened.
The state can be a verifiable representation of all the transactions.
As an extreme example, a single digest of the complete history can represent the state.
It is even verifiable as long as there are nodes that stores the history.

% Our approach is to combine the vast literature in Byzantine fault tolerance research with blockchain technology,
% and introduce a new consensus model to record the global state.

\section{Security and fault tolerance}

The second objective is fault tolerance,
where our system should be unaffected in the presence of powerful adversaries.
In particular, adversaries are Byzantine meaning that they can have arbitrary behaviour.
Thus anything is possible from simply ommitting messages to colluding with eachother in order to undermine the whole system.
This asppect usually comes for free when using a Byzantine fault tolerant consensus algorithm.

There is another aspect of fault tolerance that is transaction verifiability.
All transactions must be eventually verifiable to maintain system integrity.
Further, the validation result must be consistent.
For example, if two different honest nodes attempts verify the same transaction,
it cannot be the case that one nodes thinks that the transaction is valid but the other thinks it is invalid.

% Recall that it is not neccessary to reach consensus on all the transactions in order to record the state.
% But when using some digest (or a set of digets) to represent the state, it is also important for the transactions to be verifiable.
% Otherwise adversaries could simply store invalid transactions in the state and they would never be detected.

\section{Performance and scalability}

The last but not least, the final objective is horizontal scalability.
We wish to see the performance (global transaction rate) increase as more nodes join the network.
BitTorrent~\cite{cohen2003incentives} is an example of such a system,
where peers interact with each other to exchange files without any global bottleneck.

Early blockchain systems may run in a network of thousands of nodes, but the performance do not scale.
On the other hand, as we will see in~\Cref{sec:acs-background}, Byzantine consensus algorithms performs well but only when in a small network.
In this work, our goal is to overcome the limitations of early blockchain systems and Byzantine consensus algorithms to create a horizontally scalable blockchain.

\section{Limitations}
Our work aims to significantly lower the transaction bound.
However, the price to pay is that the Sybil attack~\cite{douceur2002sybil} prevention mechanism moves from the blockchain consensus protocol to the application layer.
For example, social network based Sybil defence mechanims use graph structure of real-world relationships~\cite{yu2006sybilguard}.
Online marketplaces such as Amazon use the rating of buyer and sellers.
Since our system is application neutral, we do not provide an explicit Sybil defence mechanism.
On the other hand, our system also has no restrictions on the Sybil defence technique
and applications built on top of our system can use the best mechanism for their purpose.

For the same reason, we do not explicitly consider spam or denial of service attacks.
Without a concrete application it is difficult to distinguish a super active user from an attacker.


% Scalability is indeed one of the key challenges we face in blockchain systems today.
% Bitcoin~\cite{bitcoin}, the largest permissionless\footnote{Explain permissionless} blockchain system
% in terms of market capitalisation~\cite{bitcoinmarketcap} has a maximum transaction rate of merely 7 transaction per second (TX/s).
% This is due to the consensus mechanism in Bitcoin, namely proof-of-work (PoW),
% miners can only create new blocks every 10 minutes and every block cannot be larger than 1 megabyte.
% Payment processors in use today such as Visa can handle transaction rates in the order of thousands~\cite{visa}.
% While Bitcoin may be a revolutionary phenomenon, it clearly cannot be ubiquitous in its current state.

% An different approach is to not reach global consensus at all.
% For instance in TrustChain~\cite{multichain} and Tangle~\cite{tangle},
% nodes in the network only store their personal ledger.
% Since consensus is left out, nodes can perform transactions as fast as their machine and network allows.
% The downside of this approach is that it cannot prevent fraud (it is possible to detect fraud).
% To examplify, a malicious node Mallory may claim she has 3 units of currency to Alice,
% but in reality Mallory already spent all of it on Bob.
% If there is no global consensus and Bob and Alice never communicate,
% then the 3 units that Alice is about to receive is nonexistent.

% The scalability property of TrustChain and Tangle are exceptionally desirable.
% The global consensus mechanism of Bitcoin and many other blockchain systems are also worthwhile for detecting or preventing fraud.
% These two properties may seem mutually exclusive, but in this work, we demonstrate the opposite.
% Specifically, we answer the following research question in the affirmative.
% \emph{Is it possible to design a blockchain fabric that can reach global consensus on the state of the system 
% and also scalable?} We define scalability as a property where if more nodes join the system, then the transaction rate should increases.
% % this is not completely true, there's a cap
