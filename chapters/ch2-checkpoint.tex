\section{Preliminaries}

\subsection{Requirements}
\begin{itemize}
\item Permissionless
\item Byzantine fault tolerant
\item No PoW
\item Works under churn
\item Underlying data structure is TrustChain
\item Detects forks or double-spends
\item No step in the protocol blocks transactions
\item Application independent
\end{itemize}

\subsection{Assumptions}
\begin{itemize}
\item Asynchronous network
\item Private and authenticated channel
\item We elect $N$ consensus promoters in every round, we assume the number of
  faulty promoters is $f$ and $N = 3f + 1$.
\item Promoters have the complete history of the previously agreed set of
  transactions (TX).
% \item Single connected component for TrustChain.
% \item No sybil attack % 
\end{itemize}

\subsection{Notation, definition and properties}
\begin{itemize}

\item $y = \texttt{h}(x)$ is a cryptographically secure hash function (random
  oracle), the domain $x$ is infinite and the range is $y \in \{0, 2^{256}-1\}$.

\item We model our system in the permissionless setting, where each
  participating party has a unique identity $i$, and a chain $B_i$.

\item A chain is a collection of blocks
  $B_i = \{b_{i,j} : j \in \{1 \dots h\} \},$
  the blocks are linked together using hash pointers, similar to bitcoin. All
  blocks contain a reference to the previous block, the very first block with no
  references is the genesis block.

  The sequence number of the block begins at 0 on the genesis block and is
  incremented for every new block. The height of the chain is $h = |B_i|$.

\item There are two sets of blocks $T_i$ and $C_i$, where $T_i \cup
  C_i = B_i$ and $T_i \cap C_i = \emptyset$. This can be seen as the
  block type, where $t_{i,j}$ and $c_{i,j}$ to represent a
  \emph{transaction block (TX block)} and \emph{checkpoint block (CP block)}
  respectively.

\item $\texttt{typeof}: B_i \rightarrow \{ \tau, \gamma \}$ returns the
  corresponding type of the block.

\item A block of type $\tau$ is a six-tuple, i.e. $$t_{i,j} =
  (\texttt{h}(b_{i,j-1}), h_s, h_r, s_s, s_r, m).$$ $h_s$ and $h_r$ denote the
  height (the sequence number for when the TX is made) of the sender and
  receiver respectively. $s_s$ and $s_r$ are the signatures of the sender and
  the receiver respectively. $i = \{s, r\}$ and $j = \{h_s, h_r\}$ depending on
  whether $i$ is the sender or the receiver.

\item Given two TX blocks $t_{i,j}$ and $t_{i',j'}$, if $i \ne i'$, $i = s$, $i'
  = r$, $h_s = h'_s$, $h_r = h'_r$, $m = m'$ and the signatures are valid, then
  we call them a \emph{pair}. Note that given one TX block, the pair can be
  determined directly.

\item If there exist two TX blocks $t_{i,j}$ and $t_{i',j'}$, where $s_s$ and
  $s_s'$ is created by the same public key, $h_s = h_s'$, but $i \neq i'$, then
  we call this a \emph{fork}.

\item A block of type $\gamma$ is a five-tuple, i.e.
  $$c_{i,j} = (\texttt{h}(b_{i,j-1}), \texttt{h}(\mathcal{C}_r), r, p, s)$$
  where $\mathcal{C}_r$ is the consensus result in round $r$ and $p \in {0,1}$
  which indicates whether $i$ wish to become a promoter in the following
  consensus round, finally $s$ is a signature of the block.

\item We define
  $$\texttt{newtx}: B_i \times B_j \times M \rightarrow B_i \times B_j$$
  as a function that creates new TX blocks. Its functionality is to
  extend the given chains using the following rule. If the input is $(B_s, B_r,
  m)$ then the output is $(B'_s, B'_r)$ where $B'_s = \{(\texttt{h}(b_{s,h_s}), h_s + 1,
  h_r + 1, s_s, s_r, m)\} \cup B_s$, $B'_r = \{(\texttt{h}(b_{r, h_r}), h_s + 1, h_r + 1,
  s_s, s_r, m)\} \cup B_r$, $h_s = |B_s|$ and $h_r = |B_r|$.

\item We define
  $$\texttt{newcp}: B_i \times \mathbb{R}_{\ge 1} \times \{0, 1\} \rightarrow B_i$$
  as a function that creates new CP blocks. Concretely, given $(B_i, r, p)$, it
  results in $\{ (\texttt{h}(b_{i,h}), H(\mathcal{C}_r), p) \}\cup B_i$ where $h =
  |B_i|$, and $\mathcal{C}_r$ is the latest consensus result at round $r$.

\item Note that in the actual system, \texttt{newtx} and \texttt{newcp} perform
  a state transition.

\item We define
  $$\texttt{round}: C_i \rightarrow \mathbb{R}_{\ge 1}$$
  as a function that gets the consensus round number used to create the given CP
  block.

\item The CP blocks that follows a pair of TX blocks must be created using the
  same $\mathcal{C}_r$, otherwise the transaction is invalid. Concretely, given
  a pair $t_{i,j}$ and $t_{i',j'}$, then there exist $c_{i, k}$ and $c_{i', k'}$
  where $j < k$, $j' < k'$, $\{ \texttt{typeof}(b_{i, x}) : x \in \{j, \dots k -
  1\}\}$ are all $\tau$, $ \{ \texttt{typeof}(b_{i', x}) : x \in \{ j', \dots k'
  - 1\} \}$ are all $\tau$ and $\texttt{round}(c_{i, k}) = \texttt{round}(c_{i',
    k'})$. This constraint is not the result of the consensus protocol, but the
  validation protocol.

\item The result of a consensus in round $r$ is a set of CP blocks. Namely,
  $$\mathcal{C}_r = (r, \{ c_{i,j} : \text{agreed by the promoters}\}).$$

\item A TX block can be valid, invalid or unknown. All TX blocks begin as
  unknown, they can be validated using our validation protocol.

\item A TX block has two \emph{ancestor} blocks. Let a pair be $t_{i,j}$ and
  $t_{i',j'}$, then $(b_{i, j-1}, b_{i', j'-1})$ is the input block of $t_{i,j}$.

\item A CP block has one \emph{ancestor} block, that is simply the block with
  the previous sequence number, i.e. the ancestor of $c_{i,j}$ is $b_{i,j-1}$.

\item Every TX block $t_{i,j}$ is enclosed by two CP blocks $(c_{i,a},
  c_{i,b})$, where
  $$a = \argmin_{k, k < j, \texttt{typeof}(b_{i,k}) = \gamma}(j - k),$$
  $$b = \argmin_{k, k > j, \texttt{typeof}(b_{i,k}) = \gamma}(k - j).$$
  We call this the \emph{enclosure} of $t_{i,j}$.

\item The \emph{piece} of $t_{i,j}$ defined by the enclosure $(c_{i,a},
  c_{i,b})$ is $\{b_{i,j} : a \le j \le b\}$.
  We define
  $$ \texttt{pieces}: B_i \rightarrow P(B_i) $$
  as the function that returns the pieces ($P$ denotes power set).

\item Every TX block $t_{i,j}$ is enclosed by two \emph{agreed} CP blocks
  $(c_{i,a}, c_{i,b})$ (CP blocks that are in some consensus result), where
  $$a = \argmin_{k, k < j, \texttt{typeof}(b_{i,k}) = \gamma}(j - k),$$
  $$b = \argmin_{k, k > j, \texttt{typeof}(b_{i,k}) = \gamma}(k - j).$$
  We call this the \emph{agreed enclosure} of $t_{i,j}$.

\item The \emph{agreed piece} of $t_{i,j}$ defined by the agreed enclosure
  $(c_{i,a}, c_{i,b})$ is $\{b_{i,j} : a \le j \le b\}$. Note that \emph{piece}
  $\subseteq$ \emph{agreed piece} for some TX block.
  We define
  $$ \texttt{a-pieces}: B_i \rightarrow P(B_i) $$
  as the function that returns the agreed pieces.

\end{itemize}

\section{Checkpoint consensus}

\subsection{Luck value}
First we define the luck value $l_{i,j} = \texttt{h}(k_i || c_{i,j})$, where $k$
is the public key of $i$. A lower luck value equates to higher luck. We assume
an application agnostic system and do not attempt to defend against the sybil
attack.

An alternative is to use \emph{proof of work}. This defends the sybil attack.
But an incentive is needed for the nodes that expend their CPU resources.

\subsection{Promoter registration}
Node $i$ can register as a promoter when the latest consensus result is
announced (suppose after the completion of round $r-1$), then it generates a new
block $b_{i,j} = \texttt{newcp}(B_i, r-1, 1)$. The current promoters (in round
$r$) may decide to include $b_{i,j}$ in the new consensus result. If $b$ is in
it, then $i$ becomes one of the promoter of round $r+1$.

We can fix the number of promoters to $N$ by sorting the promoters by their
``luck value''' and taking the first $N$. 

\subsection{Promoter invitation}
The output of promoter registration is a random set of $N$ promoters. If 1/3 of
the population is malicious, then we cannot guarantee that the chosen promoters
satisfy the $< n/3$ requirement.

Promoter invitation is an attempt to involve human in the protocol. A naive
method method is to use $N$ tickets, and then distribute them to trusted nodes.
Nodes with the ticket can forward it to others. We have to rely on the humans to
always forward the tickets to other honest humans. Finally, the nodes that hold
a ticket are promoters. The result is that we have a permissioned system.

\subsection{Setup phase}
The setup phase should satisfy the BFT conditions regarding the promoter
selection, that is:
\begin{enumerate}
\item \emph{Agreement}: If any correct node outputs a promoter $p$, then every
  correct node outputs $p$.
\item \emph{Total Order}: If one correct node outputs the sequence of promoters
  $\{p_1, p_i, \dots, p_n\}$ and another has output $\{p'_0, p'_1, \dots,
  p'_{n'} \}$, then $p_i = p'_i$ for $i \le \min(n, n')$.
\item \emph{Liveness}: All $N - f$ correct nodes terminate eventually.
\end{enumerate}

We begin in the state where $\mathcal{C}_{r-1}$ has just been agreed but has not
been disseminated yet. The exact technique to disseminate $\mathcal{C}_{r-1}$ is
irrelevant, broadcasting or gossiping are both sufficient. In fact,
dissemination is not necessary, nodes interested in the result can simply query
the promoters that created $\mathcal{C}_{r-1}$.

The consensus result $\mathcal{C}_{r-1}$ does not contain all the signatures of
the promoters. Thus, the signatures must also be disseminated by the promoters.
This can be done in the same way as consensus result dissemination. Nodes must
collect $f + 1$ signatures in order to trust $\mathcal{C}_{r-1}$ because there
is at least one honest node in $f + 1$ nodes. If there is a sufficient number of
signatures on the consensus result, we say it is \emph{valid}.

\begin{lemma}\label{lem:con_consistent}
  If a node sees a valid $\mathcal{C}_{r-1}$ and another node sees a valid
  $\mathcal{C}'_{r-1}$, then $\mathcal{C}_{r-1} = \mathcal{C}'_{r-1}$.
\end{lemma}
\begin{proof}
  $\mathcal{C}_{r-1}$ and $\mathcal{C}'_{r-1}$ are signed by at two groups of $f
  + 1$ promoters (does not have to overlap) from round $r-1$. In both groups, at
  least one node is honest. Thus the consensus result is what is actually
  agreed.
\end{proof}

\begin{lemma}\label{lem:con_alive}
  Eventually all node sees a valid $\mathcal{C}_{r-1}.$  
\end{lemma}
\begin{proof}
  (sketch) Liveness is satisfied because $\mathcal{C}_{r-1}$ is eventually propagated to
  all node by gossiping.
\end{proof}

The potential promoters now need to first discover whether
they are the first $N$ lucky promoters.

\begin{lemma}\label{lem:promoter_consistent}
  The new set of promoter for the next consensus round is consistent with
  respect to all the nodes in the network.
\end{lemma}
\begin{proof}
  (sketch) All nodes use the same deterministic function to compute the luck
  value.
\end{proof}

Nodes should wait for some time to collect the CP blocks, so they wait for some
time $\Delta$ before moving on to the next phase. Note that promoters waiting
for a some time $\Delta$ to collect transactions does not violate the
asynchronous assumption because this behaviour can be seen as a long delay in
the asynchronous system.

\begin{corollary}
  Setup phase satisfies agreement and total order because the protocol is run
  deterministicly on the same input (\cref{lem:con_consistent},
  \cref{lem:promoter_consistent}). It also satisfies liveness due to
  \cref{lem:con_alive}.
\end{corollary}

\subsection{Consensus phase}
The consensus phase should satisfy the BFT conditions regarding the CP blocks,
that is:
\begin{enumerate}
\item \emph{Agreement}: If any correct node outputs a CP block $c$, then every
  correct node outputs $c$.
\item \emph{Total Order}: If one correct node outputs the sequence of CP blocks
  $\{c_1, c_i, \dots, c_n\}$ and another has output $\{c'_0, c'_1, \dots,
  c'_{n'} \}$, then $c_i = c'_i$ for $i \le \min(n, n')$.
\item \emph{Liveness}: All $N - f$ correct nodes terminate eventually.
\end{enumerate}

We need an atomic broadcast algorithm for the consensus phase. We use a similar
but simplified construction as~\cite{miller2016honey}, where atomic broadcast is
constructed from the reliable broadcast\footnote{Reliable broadcast solves the
  Byzantine generals problem.}~\cite{bracha1984asynchronous} and asynchronous
common subset (ACS). The ACS protocol requires a binary Byzantine agreement
protocol, and for that it needs a trusted dealer to distributed the secret
shares. Promoters can check whether the secret shares are valid, but they cannot
prevent the dealer from disclosing the secrets.

There are techniques that uses no dealers. First is to use
PBFT~\cite{castro1999practical}, but we must change our asynchronous assumption
into the weak synchrony assumption. Most likely this is not possible because of
the ``When to start?'' problem. It's difficult to give a bounded delay for
propagating the consensus result.

Second is to use an inefficient binary Byzantine agreement protocol where its
message complexity is $O(N^3)$ rather than $O(N^2)$ and becomes a bottleneck. Or
a suboptimal one, e.g. $n/5$ instead of $n/3$.

Suppose we use a dealer, what is the effect to the algorithm if the dealer is
malicious?

\begin{lemma}
  Consensus phase satisfied agreement, total order and liveness.
\end{lemma}
\begin{proof}
  Defer proof? Refer to the papers.
\end{proof}

\begin{theorem}
  Checkpoint consensus satisfied agreement, total order and liveness.
\end{theorem}
\begin{proof}
  (sketch) Both phases are asynchronous so we do not need to make assumptions on
  when begin phase begins. Both phases also satisfy the agreement, total order
  and liveness.
\end{proof}

\section{Validation}\label{sec:validation}

Since we reach consensus on checkpoints rather than all the transactions, we
need to detect fraud, such as forks. Further, we need to ensure the system is
secure in a sense that valid transactions cannot be forged into invalid
transactions once it has reached consensus, and vice versa.

First, we define the requirements of a valid transaction $t_{i,j}$ as follows,
much of it is derived from the TrustChain model.

\begin{enumerate}
\item There exist a pair $t_{i', j'}$ that satisfies the pair definition.
\item $t_{i,j}$ and $t_{i', j'}$ is created using \texttt{newtx}, i.e. valid
  signatures and hash pointers, etc..
\item There exist an agreed piece that contains $t_{i, j}$ and another agreed
  piece that contains $t_{i', j'}$. All the blocks in the agreed pieces have
  valid hash pointers, the blocks in the pieces do not need to be valid.
\item The CP blocks $c_{i, k}, c_{i', k'}$ that immediately follow $t_{i, j}$
  and $t_{i', j'}$ are created using \texttt{newcp} using the same consensus
  result $\mathcal{C}_r$ as input and are in the agreed pieces.
\end{enumerate}

Blocks that do not satisfy the definition above are not necessarily invalid. It
may be the case that the validity cannot be determined due to incomplete
information. For such cases we say its validity is unknown.
Now we define an invalid transaction.

\begin{enumerate}
\item TODO
\end{enumerate}

Now we define the properties that are desired by the validation protocol.
\begin{enumerate}
\item \emph{Correctness}: The validation protocol outputs the correct result
  according to the aforementioned requirements.
\item \emph{Agreement}: If any correct node decides on the validity of a 
  transaction, then all other correct nodes are able to reach the same
  conclusion.
\item \emph{Liveness}: Any valid transactions can be validated eventually.
\item \emph{Unforgeability}: If some transaction is determined to be valid, then
  it cannot be changed to an invalid transaction, the opposite also applies.
\end{enumerate}

Note that the input of the validation protocol is a TX block, so these
properties hold with respect to TX blocks. In practice, if a node has a set of
TX blocks that are in the unknown state, then it must run the validation
protocol to determine whether they are valid. Further, these conditions do not
imply all invalid transactions (forks) can be found globally, only the validity
of the TX blocks that the honest nodes are interested in can be determined. The
advantage of this scheme is that it saves a lot of computational and bandwidth
costs because nodes only run the validation protocol on the TX blocks of their
own interest.

\subsection{Validation protocol}
Assume node $u$ is aware of all the past consensus results $\mathcal{C}_r$.
Suppose $u$ wish to validate $t_{i,j}$. It performs the following.

\begin{enumerate}
\item Determine the pair $t_{i', j'}$.
\item Find the agreed enclosure for $t_{i,j}$ and $t_{i', j'}$ from
  $\mathcal{C}_r$, otherwise return ``unknown''.
%\item Find the smallest $c_{i', b}$ such that $b > j'$ is in consensus.
\item Query $i$ and $i'$ for the agreed pieces and ensure hash pointers are
  correct. Otherwise return ``unknown''.
\item Check that $t_{i,j}$ and $t_{i', j'}$ are in the agreed pieces and are
  created correctly using \texttt{newtx}. Otherwise return ``invalid''.
\item Check the checkpoints $c_{i, k}$ and $c_{i', k'}$ that immediately follow
  $t_{i,j}$ and $t_{i', j'}$ are in the agreed pieces and are created in the
  same round, i.e. $\texttt{round}(c_{i, k}) = \texttt{round}(c_{i', k'})$.
  Otherwise return ``invalid''.
\item Return ``valid''.
\end{enumerate}

Most likely $u = i$ or $u = i'$, because they are incentivised to check the
validity of their TX blocks that are of unknown validity.

\subsection{Analysis}
In this section we analyse the validation protocol with respect to the four
properties in \cref{sec:validation}.

\begin{lemma}
  The validation protocol is correct.
\end{lemma}
\begin{proof}
  Correctness follows directly from the protocol specification, namely it
  directly implements the validation requirements.
\end{proof}

\begin{lemma}
  The validation protocol satisfies the agreement property.
\end{lemma}
\begin{proof}
  We proof by contradiction. Suppose two nodes $i$ and $j$ where $i \ne j$ runs
  the protocol on the same TX block $t_{k, l}$, $i$ outputs ``valid'' and $j$
  outputs ``invalid''. $i$ and $j$ would have both picked the same enclosure
  $c_{k, a}$ and $c_{k, b}$, as these are determined from the consensus result.
  Then $k$ must produce two agreed pieces that start with $c_{k,a}$ and end with
  $c_{k, b}$ with valid hash pointers, but one satisfies the validation protocol
  and the other one doesn't (e.g. missing $t_{k, l}$). Producing these two
  pieces is equivalent to producing a collision. Due to the properties of
  cryptographic hash functions this is not possible, thus a contradiction.
\end{proof}

\begin{lemma}
  The validation protocol does not satisfy the liveness property.
\end{lemma}
\begin{proof}
  (sketch) Nodes may be offline.
\end{proof}

There are many ways around the liveness. As long as the TX is validated once,
then the agreed pieces can be gossiped.

\begin{lemma}
  A valid TX block cannot be made into an invalid TX block and vice versa.
\end{lemma}
\begin{proof}
  We proof by contradiction. Suppose $t_{k, l}$ is determined to be valid using
  the enclosure $c_{k, a}$ and $c_{k, b}$ and the agreed piece $p$. Then $t_{k,
    l}$ is forged into an invalid transaction. To forge it into an invalid
  transaction the attacker must either tamper with the data within the block or
  remove $t_{k, l}$ from $p$. In other words create $p'$ where $p \ne p'$,
  enclosed by $c_{k, a}$ and $c_{k, b}$, and has valid hash pointers. Producing
  $p'$ is equivalent to finding a collision, thus a contradiction.

  TODO proof ``vice versa''.
\end{proof}

\subsection{Time and message complexity}
For a single transaction, the message complexity is linear with respect to the
size of the agreed pieces for both part of the TX pair. Time complexity is
constant since we only perfrom two queries (to $i$ and $i'$).

\section{Fraud detection}
Existence testing detects fraud when a single party of the TX is malicious. To
detect fraud when both parties are malicious, every node performs existence
testing on all TX blocks between CP blocks as if they are some other node. The
assignment is determined using CP block digest where every node is assigned to
the nearest node that has a higher digest, cycle back if there is no higher
digest.

If the number of malicious parties is low, then it's more probable that a fork
is detected. If where there are a large number of malicious parties, we repeat
the random sampling process.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End:
